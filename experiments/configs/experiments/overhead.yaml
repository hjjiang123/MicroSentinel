suite: overhead
run_s: 180
warmup_s: 0
repetitions: 1
modes: [baseline,perf,microsentinel]
overrides:
  instrumentation:
    pmu_events: "cycles,LLC-load-misses"
    delta_us: 10
  annotations:
    suite: overhead
workloads:
  - name: kv
    config: experiments/configs/workloads/kv.yaml
    repetitions: 1
    modes: [baseline,perf,microsentinel]
    parameters:
      delta_values_us: [10]
      pmu_events:
        - ["cycles", "LLC-load-misses"]
      rate_scan:
        samples_per_core: [500, 1000, 2000]
    overrides:
      # NOTE: The default (memcached+memtier) requires `memtier_benchmark` on the remote host.
      # This override forces the built-in Python KV server+client so the suite can run
      # end-to-end on a minimal two-node setup.
      server:
        implementation: builtin
        binary: "python3 experiments/workloads/kv/kv_server.py"
        bind_address: "211.65.193.185"
        port: 7000
        threads: 16
        numa_policy: "numactl --cpunodebind=0 --membind=0"
        dataset:
          key_space: 1048576
          value_size_bytes: 256
      clients:
        implementation: builtin
        remote:
          host: "211.65.193.243"
          workdir: "/home/hjjiang/MicroSentinel"
          metrics_dir: "/home/hjjiang/MicroSentinel/artifacts/remote"
        generator: "python3 experiments/workloads/kv/kv_client.py"
        instances: 8
        connections_per_instance: 128
        request_mix:
          get_ratio: 0.95
          set_ratio: 0.05
        key_distribution: "zipf"
        zipf_theta: 1.0
  - name: load_balancer
    config: experiments/configs/workloads/load_balancer.yaml
    repetitions: 1
    modes: [baseline,perf,microsentinel]
    parameters:
      pmu_events:
        - ["cycles", "LLC-load-misses"]
        - ["BR_MISP_RETIRED.ALL_BRANCHES"]
      rate_scan:
        samples_per_core: [500, 1000, 2000]
        event_sets:
          - ["cycles", "LLC-load-misses"]
    overrides:
      lb_node:
        # # Keep the default Python load balancer; haproxy requires additional packages.
        # numa_policy: "numactl --cpunodebind=0 --membind=0"
        numa_policy: "numactl --cpunodebind=0 --membind=0"
        # Use the native hot server so each flow maps to a distinct hot_func_i symbol.
        implementation: hot_native
        payload_bytes: 512
        flow_tag_bytes: 4
        hot_funcs: 256
        hot_bytes_per_func: 4194304  # 4 MiB per hot_func_i
        hot_stride: 64
        hot_rounds: 1

      clients:
        implementation: builtin
        remote:
          host: "211.65.193.243"
          workdir: "/home/hjjiang/MicroSentinel"
          metrics_dir: "/home/hjjiang/MicroSentinel/artifacts/remote"
        generator: python3 experiments/workloads/lb/lb_client.py
        flows: 256
  - name: nfv_service_chain
    config: experiments/configs/workloads/nfv_service_chain.yaml
    repetitions: 1
    modes: [baseline,perf,microsentinel]
    parameters:
      pmu_events:
        - ["LLC-load-misses"]
      rate_scan:
        samples_per_core: [500, 1000, 2000]
    overrides:
      traffic_generator:
        # Keep the default Python traffic generator; pktgen requires extra tooling and NIC setup.
        remote:
          host: "211.65.193.243"
          workdir: "/home/hjjiang/MicroSentinel"
          metrics_dir: "/home/hjjiang/MicroSentinel/artifacts/remote"
